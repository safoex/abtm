common:
  root_child: main2
  parameters:
    online: 1

functions:
  cpp:
    helloworld:
      name: helloworld

    hellosber:
      name: hellosber
      remap:
        times: times1

    icub_move:
      name: iCub_move

variables:
  input: ["RUNNING", "SUCCESS", "FAILED", "UNDEFINED", a,b,c,d, A00]
  output_no_send_zero: [yy,zz]
  output: [aa,bb,cc,dd]

set:
  A00: 0
  RUNNING: 0
  SUCCESS: 1
  FAILED: 2
  UNDEFINED: 3
  a: 0
  b: 0
  c: 0
  d: 0
  yy: 0
  zz: 0
  aa: 0
  bb : 0
  cc: 0
  dd: 0

templates:
  latch:
    args:
      required: [child]

    var:
      __STATE__$child: [input, UNDEFINED]

    nodes:
      $name:
        type: skipper
        children: [~mask, $child]

      ~mask:
        type: condition
        S: __STATE__$child = SUCCESS
        F: __STATE__$child = FAILED
        R: default

    children: [$child]

  reset:
    args:
      required: [child]

    var:
      __STATE__$child: [input, UNDEFINED]

    nodes:
      $name:
        type: action
        assign:
          __STATE__$child: UNDEFINED

  seq_latches:
    args:
      required: [children]
      construct:
        _children_latched:
          from: children
          V: $V_latch
      view_exclude: [children]

    nodes:
      $name:
        type: sequence
        children: $_children_latched

    unpack:
      children:
        nodes:
          $V_latch:
            type: t/latch
            child: $V

    children: $children

  seq_w_memory:
    args:
      required: [children]
      construct:
        _children_iter:
          from: children
          V: $V_iter
      view_exclude: [children]

    var:
      ~i: [input, 0]

    nodes:
      $name:
        type: sequence
        children: [~fail_reset, ~reset]

      ~fail_reset:
        type: selector
        children: [~success_reset, ~reset2_seq]

      ~success_reset:
        type: sequence
        children: $_children_iter

      ~reset:
        type: action
        script:
          ~i = 0;

      ~reset2_seq:
        type: sequence
        children: [~reset2, ~return_failure]

      ~return_failure:
        type: condition
        F: default

      ~reset2:
        type: action
        script:
          ~i = 0;

    unpack:
      children:
        nodes:
          $V_iter:
            type: sequence
            children: [$V_skip, $V_forward]

          $V_skip:
            type: skipper
            children: [$V_if, $V]

          $V_if:
            type: condition
            R: ~i = $K
            S: default

          $V_forward:
            type: sequence
            children: [$V_if2, $V_inc]

          $V_if2:
            type: condition
            R: ~i = $K
            S: default

          $V_inc:
            type: action
            script:
              ~i = ~i + 1;



  control:
    args:
      required: [children, _type]
      view_exclude: [children]

    nodes:
      $name:
        type: $_type
        children: $children

    children: $children

  action_return:
    args:
      required: [assign]
      optional:
        return: S
      view_exclude: [assign]

    nodes:
      $name:
        type: sequence
        children: [~act, ~cond]
      ~act:
        type: action
        assign: $assign
      ~cond:
        type: condition
        $return: default

    children: [~act]



nodes:
  main2:
    type: sequence
    children: [task]
#    children: [E, L, C1, LL, C2, S0]
#
#  E:
#    type: condition
#    S: z > 0
#    R: default
#    var:
#      z: [input, 0]
#
#  L:
#    type: t/latch
#    child: T
#
#  T:
#    type: sequence
#    children: [count, cond]
#
#  count:
#    type: action
#    assign:
#      x: x + 1
#    var:
#      x: [output, 0]
#
#  cond:
#    type: condition
#    S: y > 0
#    R: default
#    var:
#      y: [input, 0]
#
#  C1:
#    type: condition
#    S: v > 1
#    R: default
#    var:
#      v: [input, 0]
#
#  LL:
#    type: t/latch
#    child: RLS
#
#  RLS:
#    type: sequence
#    children: [RL, A]
#
#  RL:
#    type: t/reset
#    child: T
#
#  A:
#    type: action
#    assign:
#      z: 0
#
#  C2:
#    type: condition
#    S: z > 2
#    R: default

  task:
    type: t/seq_w_memory
    children:
      - first
      - second

  first:
    type: action
    assign:
      A: 0
    var:
      A: [input, 0]

  second:
    type: action
    assign:
      B: 1
    var:
      B: [input, 0]
#
#  last:
#    type: action
#    assign:
#      C: 42
#    var:
#      C: [input, 0]






